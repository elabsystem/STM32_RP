/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
DCMI_HandleTypeDef hdcmi;
DMA_HandleTypeDef hdma_dcmi;

I2C_HandleTypeDef hi2c2;



UART_HandleTypeDef huart1;

SRAM_HandleTypeDef hsram1;
SRAM_HandleTypeDef hsram2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_FSMC_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_DCMI_Init(void);
static void MX_SDIO_SD_Init(void);
static void MX_I2C2_Init(void);
static void MX_SPI1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */
unsigned int cam_img_size_h = 0;
unsigned int cam_img_size_t = 0;
unsigned int cam_img_content_id = 0;
unsigned int gFlagPicture = 0;
volatile unsigned int gTimeTick1 = 0;
volatile unsigned int gTimeTick2 = 0;

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
#define _TRANSFER_MODE_TCP		1
#define _TRANSFER_MODE_UDP		0

#define _CAM_SOCK_NUM		3
#define _CAM_ETHER_PORT		3000

#define _CMD_CAM_START		0xFE
#define _CMD_CAM_STOP		0xFD
#define _CMD_CAM_SIZE		0xFC
#define _CMD_LED			0xF0
#define _CMD_CAM_LINE		0xFB
#define _CMD_CAM_FRAME		0xFA

int gImgTransferFlag = 0;

#define TX_RX_MAX_BUF_SIZE			2048
//unsigned char gDestip[4] = {192, 168, 10, 184};
unsigned char gDestip[4] = {172, 30, 1, 51};
unsigned int dDestport = _CAM_ETHER_PORT;

#include "config.h"
#include "_user_code_intit.h"



#include "_user_code_w5300.h"
#include "_user_code_cam.h"


#define DATA_BUF_SIZE				2048

#if 0
int32_t process_udps(uint8_t sn, uint8_t* buf, uint16_t port)
{
   int32_t  ret;
   uint16_t size, sentsize;
   uint8_t  destip[4];
   uint16_t destport;

   switch(getSn_SR(sn))
   {
      case SOCK_UDP :
         if((size = getSn_RX_RSR(sn)) > 0)
         {
            if(size > DATA_BUF_SIZE) size = DATA_BUF_SIZE;
            ret = recvfrom(sn, buf, size, destip, (uint16_t*)&destport);
            if(ret <= 0)
            {
#ifdef _LOOPBACK_DEBUG_
               printf("%d: recvfrom error. %ld\r\n",sn,ret);
#endif
               return ret;
            }
            size = (uint16_t) ret;
            sentsize = 0;


            /*
            while(sentsize != size)
            {
               ret = sendto(sn, buf+sentsize, size-sentsize, destip, destport);
               if(ret < 0)
               {
#ifdef _LOOPBACK_DEBUG_
                  printf("%d: sendto error. %ld\r\n",sn,ret);
#endif
                  return ret;
               }
               sentsize += ret; // Don't care SOCKERR_BUSY, because it is zero.
            }*/
         }
         break;
      case SOCK_CLOSED:
#ifdef _LOOPBACK_DEBUG_
         //printf("%d:UDP loopback start\r\n",sn);
#endif
         if((ret = socket(sn, Sn_MR_UDP, port, 0x00)) != sn)
            return ret;
#ifdef _LOOPBACK_DEBUG_
         printf("%d:Opened, UDP loopback, port [%d]\r\n", sn, port);
#endif
         break;
      default :
         break;
   }
   return 1;
}

#endif

void HAL_SYSTICK_Callback(void)
{
	gTimeTick1++;
	gTimeTick2++;
}



#if _TRANSFER_MODE_TCP
int32_t ProcessCamTcps(uint8_t sn, uint8_t* buf, uint16_t port)
{
   int32_t ret;
   uint16_t size = 0, sentsize=0;

	unsigned int cmd;
	unsigned int para;
#ifdef _LOOPBACK_DEBUG_
   uint8_t destip[4];
   uint16_t destport;
#endif

   switch(getSn_SR(sn))
   {
      case SOCK_ESTABLISHED :
         if(getSn_IR(sn) & Sn_IR_CON)
         {
#ifdef _LOOPBACK_DEBUG_
			getSn_DIPR(sn, destip);
			destport = getSn_DPORT(sn);

			printf("%d:Connected - %d.%d.%d.%d : %d\r\n",sn, destip[0], destip[1], destip[2], destip[3], destport);
#endif
			setSn_IR(sn,Sn_IR_CON);
         }
		 if((size = getSn_RX_RSR(sn)) > 0) // Don't need to check SOCKERR_BUSY because it doesn't not occur.
         {
			if(size > DATA_BUF_SIZE) size = DATA_BUF_SIZE;
			ret = recv(sn, buf, size);


			cmd = buf[0];
			para = buf[2]<<8 | buf[3];

            if(cmd == _CMD_LED)
            {
            	if(para == 0)
           		{
            		Led1Off();
           		}
            	else if(para == 1)
            	{
            		Led1On();
            	}
            }
            else if(cmd == _CMD_CAM_START)
            {
            	gImgTransferFlag = 1;
            	printf("Cam Stream Start\r\n");
            }
            else if(cmd == _CMD_CAM_STOP)
            {
            	gImgTransferFlag = 0;
            	printf("Cam Stream Stop\r\n");
            }

			//sendto(sock, data_buf, len, gDestip, dDestport);


			printf("size=%d	\r\n", size);
			/*
			if(ret <= 0) return ret;      // check SOCKERR_BUSY & SOCKERR_XXX. For showing the occurrence of SOCKERR_BUSY.
			size = (uint16_t) ret;
			sentsize = 0;

			while(size != sentsize)
			{
				ret = send(sn, buf+sentsize, size-sentsize);
				if(ret < 0)
				{
					close(sn);
					return ret;
				}
				sentsize += ret; // Don't care SOCKERR_BUSY, because it is zero.
			}*/
         }
         break;
      case SOCK_CLOSE_WAIT :
#ifdef _LOOPBACK_DEBUG_
         //printf("%d:CloseWait\r\n",sn);
#endif
         if((ret = disconnect(sn)) != SOCK_OK) return ret;
#ifdef _LOOPBACK_DEBUG_
         printf("%d:Socket Closed\r\n", sn);
#endif
         break;
      case SOCK_INIT :
#ifdef _LOOPBACK_DEBUG_
    	 printf("%d:Listen, TCP server loopback, port [%d]\r\n", sn, port);
#endif
         if( (ret = listen(sn)) != SOCK_OK) return ret;
         break;
      case SOCK_CLOSED:
#ifdef _LOOPBACK_DEBUG_
         //printf("%d:TCP server loopback start\r\n",sn);
#endif
         if((ret = socket(sn, Sn_MR_TCP, port, 0x00)) != sn) return ret;
#ifdef _LOOPBACK_DEBUG_
         //printf("%d:Socket opened\r\n",sn);
#endif


         break;
      default:
         break;
   }
   return 1;
}
#endif


#if _TRANSFER_MODE_UDP


void ProcessCamUdp(unsigned int sock, unsigned char *data_buf, unsigned int Port)
{
	//포트번호
	unsigned int i;

	unsigned int cmd;
	unsigned int para;
	unsigned int len = 0;


	switch (getSn_SR(sock))
	{
	//연결되어 데이터를 수신하게 되면
		case SOCK_UDP:
		if((len = getSn_RX_RSR(sock)) > 0)
		{
			if (len > TX_RX_MAX_BUF_SIZE)len = TX_RX_MAX_BUF_SIZE;


			//DebugPrint("size size size %d", len);
			//DebugPrint("\r\n" );

			//UDP 데이터전송되면
			len = recvfrom(sock, data_buf, len, (uint8_t*)gDestip, (uint16_t*)&Port);

			cmd = data_buf[0];
			para = data_buf[2]<<8 | data_buf[3];

            if(cmd == _CMD_LED)
            {
            	if(para == 0)
           		{
            		Led1Off();
           		}
            	else if(para == 1)
            	{
            		Led1On();
            	}
            }
            else if(cmd == _CMD_CAM_START)
            {
            	gImgTransferFlag = 1;

            	DebugPrint("start\r\n", len);
            }
            else if(cmd == _CMD_CAM_STOP)
            {
            	gImgTransferFlag = 0;
            }



    		memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

sbi(GPIOD, BIT12);
    		sendto(sock, data_buf, 1460, gDestip, dDestport);
	cbi(GPIOD, BIT12);


			DebugPrint("%d.%d.%d.%d\r\n",gDestip[0],gDestip[1],gDestip[2],gDestip[3]);
			DebugPrint("port=%d\r\n",Port);
			DebugPrint("size=%d	\r\n", len);

			/*
			if(strstr(data_buf, "Led1 On"))
			{
			Led1On();
			Relay0On();
			}
			else if(strstr(data_buf, "Led1 Off"))
			{
			Led1Off();
			Relay0Off();
			}	*/

			}
			break;

		//연결종료
		case SOCK_CLOSED:
			if(socket(sock, Sn_MR_UDP, Port, 0x00)== 0)
				DebugPrint("Fail to create socket.\n\n");

			DebugPrint("Socket[2] - UDP Started.\r\n");
			break;

		default:
		//DebugPrint("sock:%x\r\n", getSn_SR(sock));
			break;
	}
}
/* USER CODE END 0 */
#endif



void CamImagTransfer(void)
{
	#if 0
	int i;
	int page;
	unsigned char data_buf[1460];

    data_buf[0] = 1<<4;
    page = ((_FRAME_BUF_SIZE*2)/_UDP_TX_BUF_SIZE);

    for(i=0;i<page;i++)
		{
			//if(i%10 == 0)printf("\r\n");

			//printf("%04x, ", FrameBuffer[i]);
			//HAL_UART_Transmit( &huart1, FrameBuffer[i], 1, 100);
			//HAL_UART_Transmit( &huart1, FrameBuffer[i]>>8, 1, 100);
			//memcpy((uint8_t *)&FrameBuffer[i], &data_buf[2], 1458);
  		data_buf[1] = i;
/*
			for(int j=0;j<(_UDP_TX_BUF_SIZE/2);j++)
			{
				//data_buf[2+j*2]=FrameBuffer2[i*_UDP_TX_BUF_SIZE+j]>>8;
				//data_buf[2+j*2+1]=FrameBuffer2[i*_UDP_TX_BUF_SIZE+j];

				//memcpy((uint8_t *)&data_buf[2], (uint8_t *)&FrameBuffer[i], _UDP_TX_BUF_SIZE/2);
			}*/
			memcpy((uint8_t *)&data_buf[2], (uint8_t *)&FrameBuffer[i*_UDP_TX_BUF_SIZE/2], _UDP_TX_BUF_SIZE);

			sendto(3, data_buf, 1460 , gDestip, dDestport);
		}

  	data_buf[0] = 0;
  	data_buf[1] = i;

  	sendto(3, data_buf, 1460 , gDestip, dDestport);
#endif


}

#if _TRANSFER_MODE_UDP
void CamImagTransferLine(unsigned int Cmd, unsigned int Para)
{
	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];

  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;
  	/*
  	FrameBuffer[0] = Cmd;
  	FrameBuffer[1] = 0;
  	FrameBuffer[2] = Para>>8;
  	FrameBuffer[3] = Para;*/
  	int ret ;

	memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);


	//if(gImgTransferFlag)
	{
		ret = sendto(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE , gDestip, dDestport);
		//ret = sendto(_CAM_SOCK_NUM, (uint8_t *)&FrameBuffer, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE , gDestip, dDestport);
	}
}


void CamImagTransferFrame(unsigned int Cmd, unsigned int Para)
{
	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];

	unsigned int size = _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE;
	/*
  	data_buf[size+0] = Cmd;
  	data_buf[size+1] = 0;
  	data_buf[size+2] = Para>>8;
  	data_buf[size+3] = Para;*/

  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;

  	int ret ;

	//send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

  	memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, size);

	if(gImgTransferFlag)
	{
		ret = sendto(_CAM_SOCK_NUM, data_buf, 4+size , gDestip, dDestport);
		/*
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}*/
	}
}
#endif


void CamImagTransferLine(unsigned int Cmd, unsigned int Para)
{

  	int ret ;

	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];
	unsigned int size = _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE;

  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;
/*

	//memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer+Para*_IMAGE_SIZE_X, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);
  	memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

	//send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

	if(gImgTransferFlag)
	{
		ret = send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}
	}*/

  	//memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, size);
  	FrameBuffer[0] = Cmd;
  	FrameBuffer[1] = 0;
  	FrameBuffer[2] = Para>>8;
  	FrameBuffer[3] = Para;

	if(gImgTransferFlag)
	{
		//ret = send(_CAM_SOCK_NUM, (uint8_t *)data_buf, size+4);
		//HAL_Delay(1);
		ret = send(_CAM_SOCK_NUM, (uint8_t *)FrameBuffer, size+4);
		/*
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}*/
	}
}

void CamImagTransferFrame(unsigned int Cmd, unsigned int Para)
{
	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];

	unsigned int size = _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE;

	/*
  	data_buf[size+0] = Cmd;
  	data_buf[size+1] = 0;
  	data_buf[size+2] = Para>>8;
  	data_buf[size+3] = Para;
*/


  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;

  	int ret ;

	//send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

  	//memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, size);

	if(gImgTransferFlag)
	{
		HAL_Delay(1);
		ret = send(_CAM_SOCK_NUM, data_buf, size+4);
		HAL_Delay(1);
		/*
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}*/
	}
}

#if 0//_TRANSFER_MODE_TCP
void CamImagTransferLine(unsigned int Cmd, unsigned int Para)
{

  	int ret ;

	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];
	unsigned int size = _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE;

  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;
/*

	//memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer+Para*_IMAGE_SIZE_X, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);
  	memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

	//send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

	if(gImgTransferFlag)
	{
		ret = send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}
	}*/

  	memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, size);
  	/*

  	FrameBuffer[0] = Cmd;
  	FrameBuffer[1] = 0;
  	FrameBuffer[2] = Para>>8;
  	FrameBuffer[3] = Para;
*/
	if(gImgTransferFlag)
	{
		ret = send(_CAM_SOCK_NUM, (uint8_t *)data_buf, size+4);
		//HAL_Delay(1);
		//ret = send(_CAM_SOCK_NUM, (uint8_t *)FrameBuffer, size+4);
		/*
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}*/
	}
}

void CamImagTransferFrame(unsigned int Cmd, unsigned int Para)
{
	unsigned char data_buf[2048*_UDP_TX_BUF_RATE];

	unsigned int size = _IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE;

	/*
  	data_buf[size+0] = Cmd;
  	data_buf[size+1] = 0;
  	data_buf[size+2] = Para>>8;
  	data_buf[size+3] = Para;
*/


  	data_buf[0] = Cmd;
  	data_buf[1] = 0;
  	data_buf[2] = Para>>8;
  	data_buf[3] = Para;

  	int ret ;

	//send(_CAM_SOCK_NUM, data_buf, 4+_IMAGE_SIZE_X*2*_UDP_TX_BUF_RATE);

  	//memcpy((uint8_t *)&data_buf[4], (uint8_t *)&FrameBuffer, size);

	if(gImgTransferFlag)
	{
		HAL_Delay(1);
		ret = send(_CAM_SOCK_NUM, data_buf, size+4);
		HAL_Delay(1);
		/*
		if(ret < 0)
		{
			close(_CAM_SOCK_NUM);
			return;
		}*/
	}
}
#endif


/**
  * @brief  The application entry point.
  * @retval int
  */

int main(void)
{
  /* USER CODE BEGIN 1 */

    int  i;
    int page;
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_FSMC_Init();
  MX_USART1_UART_Init();
  MX_DCMI_Init();
  //MX_SDIO_SD_Init();
  MX_I2C2_Init();
  MX_SPI1_Init();
  /* USER CODE BEGIN 2 */
  //init_project();
	_init_cam();

	_InitW5300();
	_Init_Web();


#define DEBUG 0





  /* USER CODE END 2 */
	uint32_t line_old = 0;
	uint32_t frame = 0;
	uint32_t frame_rate = 0;

/*
	while(1)
	{
		//ProcessCamTcps(_CAM_SOCK_NUM, ethBuf0, dDestport);
		//ProcessCamUdp(_CAM_SOCK_NUM, ethBuf0, dDestport);

		//sbi(GPIOD, BIT12);
		//CamImagTransferLine(_CMD_CAM_LINE, gLineCnt);
		//cbi(GPIOD, BIT12);

		loopback_tcps(0, ethBuf0, 3000);
		//loopback_udps(0, ethBuf0, 3000);

		//HAL_Delay(1);
	}
*/

  	for(i=0;i<_FRAME_BUF_SIZE;i++)
		{

  		FrameBuffer2[i] = 0xf800;//red

		}

	  //ov2640_Init(CAMERA_I2C_ADDRESS, CAMERA_R160x120);
	  //HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, (uint32_t)&FrameBuffer, _FRAME_BUF_SIZE/2);


  		//cket(_CAM_SOCK_NUM, Sn_MR_UDP, dDestport, 0x00);
	  HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, (uint32_t)&FrameBuffer, _IMAGE_SIZE_X*_UDP_TX_BUF_RATE);

	  while(1)
	  {
			ProcessCamTcps(_CAM_SOCK_NUM, ethBuf0, dDestport);

		  	if(gCameraFrameFlag>0)		// 디지탈 카메라로부터 1프레임 들어왔슴.
		  	{
		  		gCameraFrameFlag = 0;
		  		CamImagTransferFrame(_CMD_CAM_FRAME, gLineCnt);

		  		printf(">%d, %d\r\n", gFrameCnt, gLineCnt);
		  		gFrameCnt++;
		  		gLineCnt = 0;
		  	}


			if(gCameraLineFlag>0)
			{
				gCameraLineFlag = 0;

				CamImagTransferLine(_CMD_CAM_LINE, gLineCnt);
				gLineCnt++;
			}

	  }
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */


#if 0
  while (1)
  {
    /* USER CODE END WHILE */
	  //loopback_tcps(0, ethBuf0, 5000);

	#if _TRANSFER_MODE_UDP
	 ProcessCamUdp(_CAM_SOCK_NUM, ethBuf0, dDestport);
	#endif

	#if _TRANSFER_MODE_TCP
	ProcessCamTcps(_CAM_SOCK_NUM, ethBuf0, dDestport);
	#endif
	  //loopback_udps(1, ethBuf0, 3000);
	 // _WEB_PROCESS();
/*
	  if(gFlagPicture == 1)
	  {
		  if(gTimeTick1>5000)
		  {
			  gTimeTick1 = 0;

			  gFlagPicture = 0;
			  //mutex = 1;
		  }

	  }*/
/*
	  if(gLineCnt>=RES_Y)
	  {

		  printf("%d, %d(%d)\r\n", gLineCnt, gFrameCnt, gTimeTick1);

		  //gTimeTick1 = 0;
		  //gLineCnt = 0;

		  gFrameCnt++;
	  }*/


	  if(gTimeTick1>999)
	  {
		  gTimeTick1 = 0;

		  frame_rate = gFrameCnt - line_old;
		  //frame = gFrameCnt;

		  line_old = gFrameCnt;
		  gFrameRate = gFrameCnt;

	  		printf("%d, %d(%d)\r\n", gLineCnt, gFrameCnt, gFrameRate);

	  		//gTimeTick2 = 0;
	  		//gLineCnt = 0;
	  		gFrameCnt = 0;
	  		//gDmaCnt = 0;

	  }


		/*
		else
		{

			//gLineCnt = 0;
			cbi(GPIOD, BIT12);
			CamImagTransferLine(_CMD_CAM_LINE, gLineCnt);
			sbi(GPIOD, BIT12);
		}*/



	  	if(gCameraFrameFlag>0)		// 디지탈 카메라로부터 1프레임 들어왔슴.
	  	{
#if 1
	  		gCameraFrameFlag = 0;
	  		sbi(GPIOD, BIT12);
	  		CamImagTransferFrame(_CMD_CAM_FRAME, gLineCnt);
	  		cbi(GPIOD, BIT12);

	  		printf(">%d, %d\r\n", gFrameCnt, gLineCnt);
	  		gFrameCnt++;
	  		gLineCnt = 0;

#endif

#if 0
	  		//LCD_puts_image_RGB565((const uint16_t *)FrameBuffer);				// 그냥 전송
	  		//LCD_puts_image_RGB565_DMA((const uint16_t *)FrameBuffer);			// DMA 전송
	  		Remainder = 2;	// 첫번째 부분을 LCD로 보냈음을 표시. 나머지는 앞서 등록한 콜백함수에서 처리할 것임.

	  		//printf("%d, %d(%d), %d\r\n", gLineCnt, gFrameCnt, frame_rate, gDmaCnt);
	  		//printf("%d, %d(%d)\r\n", gLineCnt, gFrameCnt, gDmaCnt);

	  		if(gImgTransferFlag)
	  		{
				CamImagTransfer();

				//memcpy((uint8_t*)FrameBuffer2, (uint8_t*)FrameBuffer, _FRAME_BUF_SIZE*2);
				printf("%d\r\n", gLineCnt);
	  		}
	  		/*for(i=0;i<_FRAME_BUF_SIZE;i++)
	  		{
	  			//if(i%10 == 0)printf("\r\n");

	  			//printf("%04x, ", FrameBuffer[i]);
	  			//HAL_UART_Transmit( &huart1, FrameBuffer[i], 1, 100);
	  			//HAL_UART_Transmit( &huart1, FrameBuffer[i]>>8, 1, 100);
	  		}*/
	  		gTimeTick2 = 0;

	  		gFrameCnt = 0;

	  		gLineCnt = 0;
	  		gDmaCnt = 0;
#endif
	  	}




#if 1
		if(gCameraLineFlag>0)
		{
			gCameraLineFlag = 0;

/*
			if(gLineCnt>=480)
			{
				gLineCnt = 0;
				//CamImagTransferFrame(_CMD_CAM_FRAME, gLineCnt);

				gFrameCnt++;
			}*/

			sbi(GPIOD, BIT12);
			CamImagTransferLine(_CMD_CAM_LINE, gLineCnt);
			gLineCnt++;
			cbi(GPIOD, BIT12);


			//CamImagTransferLine(_CMD_CAM_FRAME, gFrameRate);
		}
#endif

	  if(!HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_6))
	  {

		  HAL_DCMI_Stop(&hdcmi);
		  ov2640_Init(CAMERA_I2C_ADDRESS, CAMERA_R160x120);

		  HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, (uint32_t)&FrameBuffer, _FRAME_BUF_SIZE/2);
		  //HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_SNAPSHOT, (uint32_t)(&FrameBuffer), _FRAME_BUF_SIZE/2);


		  /*
		  	for(i=0;i<_FRAME_BUF_SIZE;i++)
	  		{

		  		FrameBuffer[i] = 0xf800;//red

	  		}
	  		*/
		  	 printf("capture image \r\n");
		  HAL_Delay(300);
	  }


	  /*
	  if(gImgTransferFlag)
	  {
	  	  memcpy((uint8_t *)&data_buf[2], (uint8_t *)&FrameBuffer[gImgSendIndex*_UDP_TX_BUF_SIZE/2], _UDP_TX_BUF_SIZE);

	  	  sendto(3, data_buf, 1460 , gDestip, dDestport);
	  }*/




	  if(!HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_13))
	  {
		  //CamImagTransfer();
		  //gImgTransferFlag ^=1;
		  Remainder = 0;
		  HAL_Delay(300);
		  	//data_buf[0] = 1460>>8;
		  	//data_buf[1] = 1460&0xFF;

		  	//FrameBuffer[0] =0x1234;
		  	//FrameBuffer[1] =0x5678;
#if 0
		    data_buf[0] = 1<<4;
		    page = ((_FRAME_BUF_SIZE*2)/_UDP_TX_BUF_SIZE);

		    for(i=0;i<page-1;i++)
	  		{
	  			//if(i%10 == 0)printf("\r\n");

	  			//printf("%04x, ", FrameBuffer[i]);
	  			//HAL_UART_Transmit( &huart1, FrameBuffer[i], 1, 100);
	  			//HAL_UART_Transmit( &huart1, FrameBuffer[i]>>8, 1, 100);
	  			//memcpy((uint8_t *)&FrameBuffer[i], &data_buf[2], 1458);
		  		data_buf[1] = i;
/*
	  			for(int j=0;j<(_UDP_TX_BUF_SIZE/2);j++)
  				{
	  				//data_buf[2+j*2]=FrameBuffer2[i*_UDP_TX_BUF_SIZE+j]>>8;
	  				//data_buf[2+j*2+1]=FrameBuffer2[i*_UDP_TX_BUF_SIZE+j];

	  				//memcpy((uint8_t *)&data_buf[2], (uint8_t *)&FrameBuffer[i], _UDP_TX_BUF_SIZE/2);
  				}*/
	  			memcpy((uint8_t *)&data_buf[2], (uint8_t *)&FrameBuffer[i*_UDP_TX_BUF_SIZE/2], _UDP_TX_BUF_SIZE);

	  			sendto(3, data_buf, 1460 , gDestip, dDestport);
	  		}

		  	data_buf[0] = 0;
		  	data_buf[1] = i;

		  	sendto(3, data_buf, 1460 , gDestip, dDestport);

#endif
		  printf("send\r\n");

		  HAL_Delay(100);
	  }
#if 0
	  if(mutex == 0)
	  {
		  if(gTimeTick1>2000)
		  {
			  gTimeTick1 = 0;

			  mutex = 1;
		  }
	  }

	if (mutex == 1)
	{
		memset(frameBuffer, 0, sizeof(frameBuffer));
		OV2640_CaptureSnapshot((uint32_t) frameBuffer, imgRes);

		printf("shot start size = %d\r\n ",sizeof(frameBuffer));
		i = 0;
		cam_img_size_h = 0;
		cam_img_size_t = 0;

		bufferPointer = 0;
		mutex = 2;
	}
	else if(mutex == 2)
	{
		if (headerFound == 0 && frameBuffer[bufferPointer] == 0xFF
			&& frameBuffer[bufferPointer + 1] == 0xD8)
		{
			headerFound = 1;

			cam_img_size_h = bufferPointer;

			#ifdef DEBUG
			printf("\r\nFound header of JPEG file ->%d\r\n", cam_img_size_h);
			#endif
		}

		if (headerFound == 1 && frameBuffer[bufferPointer] == 0xFF
			&& frameBuffer[bufferPointer + 1] == 0xD9)
		{
			bufferPointer = bufferPointer + 2;

			cam_img_size_t = bufferPointer;

			#ifdef DEBUG
			printf("\r\nFound EOF of JPEG file ->%d\r\n", cam_img_size_t);
			#endif

			headerFound = 0;




			#ifdef DEBUG
				//cam_img_size = bufferPointer;
				printf("Image size: %d bytes \r\n", cam_img_size_t - cam_img_size_h);
			#endif


			reg_httpServer_webContentM(cam_img_content_id, (uint8_t *)"cam_img.jpg", (uint8_t *)&frameBuffer[cam_img_size_h], cam_img_size_t - cam_img_size_h);


			OV2640_StopDCMI();
			gTimeTick1 = 0;
			mutex = 0;



		}


		if (bufferPointer > imgRes)
		{
			printf("\r\n out of buff = %d\r\n", bufferPointer);

			OV2640_StopDCMI();
			gTimeTick1 = 0;
			mutex = 0;
		}

		bufferPointer++;
	}
#endif


    /* USER CODE BEGIN 3 */
  }
#endif
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSI, RCC_MCODIV_1);
}

/**
  * @brief DCMI Initialization Function
  * @param None
  * @retval None
  */
static void MX_DCMI_Init(void)
{

  /* USER CODE BEGIN DCMI_Init 0 */

  /* USER CODE END DCMI_Init 0 */

  /* USER CODE BEGIN DCMI_Init 1 */

  /* USER CODE END DCMI_Init 1 */
#if 0
  hdcmi.Instance = DCMI;
  hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
  hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_FALLING;
  hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
  hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
  hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
  hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
  hdcmi.Init.JPEGMode = DCMI_JPEG_DISABLE;
  if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
  {
    Error_Handler();
  }
#endif


  hdcmi.Instance = DCMI;
  hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
  hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
  hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
  hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
  hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
  hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
  hdcmi.Init.JPEGMode = DCMI_JPEG_DISABLE;
  /*
  hdcmi.Init.ByteSelectMode = DCMI_BSM_ALL;
  hdcmi.Init.ByteSelectStart = DCMI_OEBS_ODD;
  hdcmi.Init.LineSelectMode = DCMI_LSM_ALL;
  hdcmi.Init.LineSelectStart = DCMI_OELS_ODD;*/
  if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
  {
    Error_Handler();
  }

  #if 0


  /* USER CODE BEGIN DCMI_Init 2 */
	hdcmi.Instance = DCMI;
	hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
	hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
	hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
	hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
	hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
	hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
	hdcmi.Init.JPEGMode = DCMI_JPEG_ENABLE;
	/*
	hdcmi.Init.ByteSelectMode = DCMI_BSM_ALL;
	hdcmi.Init.ByteSelectStart = DCMI_OEBS_ODD;
	hdcmi.Init.LineSelectMode = DCMI_LSM_ALL;
	hdcmi.Init.LineSelectStart = DCMI_OELS_ODD;*/

	if (HAL_DCMI_Init(&hdcmi) != HAL_OK) {
		Error_Handler();
	}
  /* USER CODE END DCMI_Init 2 */
#endif
}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */


  /* USER CODE END I2C2_Init 2 */

}


/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7|GPIO_PIN_8, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_3, GPIO_PIN_RESET);

  /*Configure GPIO pins : PE2 PE3 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pin : PF6 */
  GPIO_InitStruct.Pin = GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pin : PC2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : PB1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PD13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*Configure GPIO pins : PG7 PG8 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : PD3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

}

/* FSMC initialization function */
static void MX_FSMC_Init(void)
{

  /* USER CODE BEGIN FSMC_Init 0 */

  /* USER CODE END FSMC_Init 0 */

  FSMC_NORSRAM_TimingTypeDef Timing = {0};

  /* USER CODE BEGIN FSMC_Init 1 */

  /* USER CODE END FSMC_Init 1 */

  /** Perform the SRAM1 memory initialization sequence
  */
  hsram1.Instance = FSMC_NORSRAM_DEVICE;
  hsram1.Extended = FSMC_NORSRAM_EXTENDED_DEVICE;
  /* hsram1.Init */
  hsram1.Init.NSBank = FSMC_NORSRAM_BANK2;
  hsram1.Init.DataAddressMux = FSMC_DATA_ADDRESS_MUX_DISABLE;
  hsram1.Init.MemoryType = FSMC_MEMORY_TYPE_SRAM;
  hsram1.Init.MemoryDataWidth = FSMC_NORSRAM_MEM_BUS_WIDTH_16;
  hsram1.Init.BurstAccessMode = FSMC_BURST_ACCESS_MODE_DISABLE;
  hsram1.Init.WaitSignalPolarity = FSMC_WAIT_SIGNAL_POLARITY_LOW;
  hsram1.Init.WrapMode = FSMC_WRAP_MODE_DISABLE;
  hsram1.Init.WaitSignalActive = FSMC_WAIT_TIMING_BEFORE_WS;
  hsram1.Init.WriteOperation = FSMC_WRITE_OPERATION_ENABLE;
  hsram1.Init.WaitSignal = FSMC_WAIT_SIGNAL_DISABLE;
  hsram1.Init.ExtendedMode = FSMC_EXTENDED_MODE_DISABLE;
  hsram1.Init.AsynchronousWait = FSMC_ASYNCHRONOUS_WAIT_DISABLE;
  hsram1.Init.WriteBurst = FSMC_WRITE_BURST_DISABLE;
  hsram1.Init.PageSize = FSMC_PAGE_SIZE_NONE;
  /* Timing */

  /*
  Timing.AddressSetupTime = 2;
  Timing.AddressHoldTime = 2;
  Timing.DataSetupTime = 4;
  Timing.BusTurnAroundDuration = 4;
  Timing.CLKDivision = 4;
  Timing.DataLatency = 4;
  Timing.AccessMode = FSMC_ACCESS_MODE_A;
  */
#if _TRANSFER_MODE_UDP
  Timing.AddressSetupTime = 6;
  Timing.AddressHoldTime = 6;
  Timing.DataSetupTime = 6;
  Timing.BusTurnAroundDuration = 8;
  Timing.CLKDivision = 6;
  Timing.DataLatency = 6;
#endif

#if _TRANSFER_MODE_TCP

  Timing.AddressSetupTime = 4;
  Timing.AddressHoldTime = 4;
  Timing.DataSetupTime = 4;
  Timing.BusTurnAroundDuration = 4;
  Timing.CLKDivision = 4;
  Timing.DataLatency = 4;
  /*
  Timing.AddressSetupTime = 3;
  Timing.AddressHoldTime = 3;
  Timing.DataSetupTime = 3;
  Timing.BusTurnAroundDuration = 3;
  Timing.CLKDivision = 3;
  Timing.DataLatency = 3;*/
#endif
  /* ExtTiming */

  if (HAL_SRAM_Init(&hsram1, &Timing, NULL) != HAL_OK)
  {
    Error_Handler( );
  }

  /** Perform the SRAM2 memory initialization sequence
  */
  hsram2.Instance = FSMC_NORSRAM_DEVICE;
  hsram2.Extended = FSMC_NORSRAM_EXTENDED_DEVICE;
  /* hsram2.Init */
  hsram2.Init.NSBank = FSMC_NORSRAM_BANK4;
  hsram2.Init.DataAddressMux = FSMC_DATA_ADDRESS_MUX_DISABLE;
  hsram2.Init.MemoryType = FSMC_MEMORY_TYPE_SRAM;
  hsram2.Init.MemoryDataWidth = FSMC_NORSRAM_MEM_BUS_WIDTH_16;
  hsram2.Init.BurstAccessMode = FSMC_BURST_ACCESS_MODE_DISABLE;
  hsram2.Init.WaitSignalPolarity = FSMC_WAIT_SIGNAL_POLARITY_LOW;
  hsram2.Init.WrapMode = FSMC_WRAP_MODE_DISABLE;
  hsram2.Init.WaitSignalActive = FSMC_WAIT_TIMING_BEFORE_WS;
  hsram2.Init.WriteOperation = FSMC_WRITE_OPERATION_ENABLE;
  hsram2.Init.WaitSignal = FSMC_WAIT_SIGNAL_DISABLE;
  hsram2.Init.ExtendedMode = FSMC_EXTENDED_MODE_DISABLE;
  hsram2.Init.AsynchronousWait = FSMC_ASYNCHRONOUS_WAIT_DISABLE;
  hsram2.Init.WriteBurst = FSMC_WRITE_BURST_DISABLE;
  hsram2.Init.PageSize = FSMC_PAGE_SIZE_NONE;
  /* Timing */
  Timing.AddressSetupTime = 15;
  Timing.AddressHoldTime = 15;
  Timing.DataSetupTime = 255;
  Timing.BusTurnAroundDuration = 15;
  Timing.CLKDivision = 16;
  Timing.DataLatency = 17;
  Timing.AccessMode = FSMC_ACCESS_MODE_A;
  /* ExtTiming */

  if (HAL_SRAM_Init(&hsram2, &Timing, NULL) != HAL_OK)
  {
    Error_Handler( );
  }

  /* USER CODE BEGIN FSMC_Init 2 */

  /* USER CODE END FSMC_Init 2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
